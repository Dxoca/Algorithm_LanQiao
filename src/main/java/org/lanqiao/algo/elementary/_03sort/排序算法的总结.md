排序算法的总结：
#基础排序
a.冒泡
    谁大谁上，每一轮都把最大的顶到天花板
    效率太低O(n²)——掌握swap

b.选择排序，效率较低，但经常用它内部的循环方式来找最大值和最小值——怎么一次性求出数组的最大值和最小值
    O(n²)
c.插排，虽然平均效率低，但是在序列基本有序时，它很快，所以也有其适用范围
    Arrays这个工具类在1.7里面做了较大改动

d.希尔（缩小增量排序），是插排的改良，对空间思维训练有帮助

#分治法
1.子问题拆分
2.递归求解子问题
3.合并子问题的解

e.快排是软件工业中最常见的常规排序法，其**双向指针扫描**和**分区**算法是核心，
往往用于解决类似问题，特别地partition算法用来划分不同性质的元素，
partition->selectK,也用于著名的top问题
O(NlgN)，但是如果主元不是中位数的话，特别地如果每次主元都在数组区间的一侧，复杂度将退化为N²
工业优化：三点取中法，绝对中值法，小数据量用插入排序
快排重视子问题拆分

f.归并排序，空间换时间——逆序对数
归并重视子问题的解的合并

g.堆排序，用到了二叉堆数据结构，是继续掌握树结构的起手式
=插排+二分查找

上面三个都是NlgN的复杂度，其中快排表现最好，是原址的不用开辟辅助空间；堆排也是原址的，但是常数因子较大，不具备优势。

上面7种都是基于比较的排序，可证明它们在元素随机顺序情况下最好是NlgN的，用决策树证明

--------------------------------

下面三个是非比较排序，在**特定情况**下会比基于比较的排序要快：

1.计数排序，可以说是最快的：O(N+k),k=maxOf(sourceArr)，
用它来解决问题时必须注意如果序列中的值分布非常广（最大值很大，元素分布很稀疏），
空间将会浪费很多
所以计数排序的适用范围是：**序列的关键字比较集中，已知边界，且边界较小**

2.桶排序：先分桶，再用其他排序方法对桶内元素排序，按桶的编号依次检出。（分配-收集）
用它解决问题必须注意序列的值是否均匀地分布在桶中。
如果不均匀，那么个别桶中的元素会远多于其他桶，桶内排序用比较排序，极端情况下，全部元素在一个桶内
还是会退化成NlgN

其时间复杂度是：时间复杂度： O(N+C)，其中C=N*(logN-logM)，约等于N*lgN
N是元素个数，M是桶的个数。


3.基数排序，kN级别（k是最大数的位数）是整数数值型排序里面又快又稳的，无论元素分布如何，
只开辟固定的辅助空间（10个桶）

对比桶排序，基数排序每次需要的桶的数量并不多。而且基数排序几乎不需要任何“比较”操作，而桶排序在桶相对较少的情况下，
桶内多个数据必须进行基于比较操作的排序。
因此，在实际应用中，对十进制整数来说，基数排序更好用。


期望水准：
1、准确描述算法过程
2、写出伪代码
3、能分析时间复杂度
4、能灵活应用（知道优缺点和应用场景）



在查找算法中，基于比较的查找算法最好的时间复杂度也是O(logN)。
比如折半查找、平衡二叉树、红黑树等。
但是Hash表却有O(C)线性级别的查找效率(不冲突情况下查找效率达到O(1))。
大家好好体会一下：Hash表的思想和桶排序是不是有异曲同工之妙呢?